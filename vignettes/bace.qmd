---
title: "BACE: Bayesian Phylogenetic and Correlated Trait Imputation"
date: "`r Sys.Date()`"
author: "Shinichi Nakagawa, Szymek Drobniak, Daniel Noble"
bibliography: ../bib/BACE.bib
format:
  html:
    toc: true
    toc-location: left
    toc-depth: 3
    toc-title: "**Table of Contents**"
    output-file: "index.html"
    theme: cosmo
    embed-resources: true
    code-fold: show
    code-tools: true
    number-sections: true
    fontsize: "12"
    code-overflow: wrap
crossref: 
  fig-title: Figure     # (default is "Figure")
  tbl-title: Table     # (default is "Table")
  title-delim: â€”     # (default is ":")
  fig-prefix: Fig.   # (default is "Figure")
  tbl-prefix: Tab.    # (default is "Table")
editor_options: 
  chunk_output_type: console
---

# Introduction
We provide a brief introduction to the *BACE* package for Bayesian phylogenetic and correlated trait imputation. The *BACE* package allows users to impute missing data in comparative datasets using Bayesian methods that account for phylogenetic relationships among species.

# Installation
You can install the *BACE* package from GitHub using the following command:

```{r}
#| label: install_bace
#| echo: true
#| message: false
#| warning: false
#| eval: true

# Install from github and load
#install.packages("pacman")
  pacman::p_load(devtools)
devtools::install_github("daniel1noble/BACE")
  pacman::p_load(BACE, ape, phytools, MCMCglmm, dplyr, magrittr)
```

If you encounter any issues during installation, please ensure that you have the required dependencies installed.

# Documentation

The main function in the *BACE* package is `bace_imp()`, which performs Bayesian imputation using chained equations. You can access the documentation for this function using the following command:
```{r}
#| label: bace_imp_doc
#| echo: true
?bace_imp
```

As you will see, the function allows you to specify fixed effects, random effects, phylogenetic tree, and other parameters for the imputation process. At the bare minimum, you need to provide a formula for the fixed effects, a formula for the random effects (including phylogeny), a phylogenetic tree, and the dataset with missing values.

# Example Usage

## Simulating Data
We'll first simulate a dataset with missing values and a phylogenetic tree. We can do this using the `sim_bace()` function.

```{r}
#| label: simulate_data
#| echo: true

# Set seed for reproducibility
set.seed(123)

# Simulate data. Note that threshold4 indicates an ordinal variable with 4 levels, and multinomial3 indicates a categorical variable with 3 levels. You can replace the numbers 
sim_data <- sim_bace(response_type = "poisson",
                   predictor_types = c("gaussian", "binary", "threshold4", "multinomial3"),
                      phylo_signal = c(0.55, 0.75, 0.8, 0.7, 0.7),
                       missingness = c(0.2, 0.3, 0.4, 0.2, 0.5),
                           n_cases = 100,
                         n_species = 100)

```

We can then view the simulated data and phylogenetic tree because the `sim_bace()` function returns a list containing both objects. It also has a lot of other useful information about the simulation users can explore.

```{r}
#| label: view_simulated_data
#| echo: true

# Object contains both the simulated data and phylogeny
    data <- sim_data$data
    tree <- sim_data$tree

# View first few rows of the data
    head(data)
```

Here, we can see that the dataset contains lots of missing values across different variable types. Of course, with normal modelling, we would need to exclude these cases to use a complete dataset. However, with *BACE* we simply feed in the entire dataset, specify the models we want to use for imputation (or the real model of interest), and impute the missing data. 

## Using *BACE* for Imputation
Now that we have the data and the phylogenetic tree we can use the `bace_imp()` function to impute the missing data. 

:::::: {.callout-caution}
It's very important to ensure that all variables are correctly classified in the dataset (e.g., factors for categorical variables, numeric for continuous variables, etc.) before running the imputation. *BACE* will fit different models for different variable types, and so, if they have not been correctly classified you will be modeling the variable incorrectly. 

If you want to see what *BACE* has classified each variable as, you can use the extract the types using the following command:

```{r}
#| label: check_variable_types
#| echo: true 
#| eval: false

bace_types <- bace_impute$types
```

Importantly, users also need to think carefully about the distributions of the variables themselves and transform them if necessary prior to running `bace_imp` (e.g., log-transforming skewed continuous variables).
:::


There are two ways you can use `bace_imp`. The first is to specify a list of all the formulas for each variable you would like to fit. It is important here that, if you provide a list, that any variable with missing data is found as a response variable. This must be the case because *BACE* will not automatically build models for other variables if you provide a list of formulas (but see below). For example, we can run *BACE* as follows. Note that we specify a formula for each variable in the dataset that has missing data.



```{r}
#| label: bace_imputation
#| echo: true 
#| eval: false

# First check that all variables are correctly classified. If using sim_bace() this is done automatically, but always worth checking.
  str(data)

# Perform BACE imputation. Here we specify models for each variable in the dataset.
bace_impute <- bace_imp(fixformula = list("y ~ x1 + x2",
                                          "x1 ~ x2",
                                          "x2 ~ x4",
                                          "x3 ~ x1 + x2",
                                          "x4 ~ x1 + x2"),
                    ran_phylo_form = "~ 1 |species",
                             phylo = tree,
                              data = data,
                              runs = 5, verbose = FALSE)
                       
```

What *BACE* will do here is fit a `MCMCglmm` model for each of the response variables specified in the formula list. At the first iteration, it will fill in missing values for any predictors using either their mean (for continuous variables) or randomly sampled values (for categorical variables). Models will then be fit using this complete predictor set and predictions will be made for missing values of the response variable. In the next run, those predictions will be used to 'fill' in missing values in any predictors instead. This cycle will continue until the predicted values converge. This process is repeated for the number of iterations specified by the `runs` argument. All the models will include the phylogenetic random effect specified in the `ran_phylo_form` argument.

The second way to use *BACE* is to just provide a model with your main variables. This may be because you have an *a priori* model in mind, as such, you can also use `bace_imp` by simply feeding in a single formula as below. Here, *BACE* will automatically build models for the other variables based on their types and the variables present in the dataset. It will impute missing values in the same way as described above, but using all other variables as predictors. You can also specify interactions if you wish. We can run *BACE* in this way as follows (this time using verbose = TRUE to see more output during the imputation process):

```{r}
#| label: bace_imputation_simple
#| echo: true

# Fit BACE with a single formula
bace_impute2 <- bace_imp(fixformula = "y ~ x1 + x2",
                     ran_phylo_form = "~ 1 |species",
                              phylo = tree,
                               data = data,
                               runs = 5, nitt = 20000, burnin = 5000, thin = 10)     
```

As you can see from the printout above, *BACE* provides a summary of the imputation process, including the number of models fitted, parameters estimated, and effective sample sizes which evaluate how well the MCMC chains for parameters are mixing. This is important to check to ensure that the imputation is performing well.

## Evaluating Final Models

*BACE* returns a list of models for each variable that was imputed. You can access these models and evaluate them as you would any `MCMCglmm` model. This is important for  checking model fit and convergence along with downstream inference. For example, you can check the summary of the model for the response variable `y` as follows:

```{r}
#| label: evaluate_models
#| echo: true

# Access the model for the response variable 'y'
model_y <- bace_impute2$models[["y"]] 

# View summary of the model
summary(model_y)

# Plot trace and density plots for model parameters
plot(model_y)
```

We can see here that the phylogenetic variance estimate (i.e., `species` random effect) is mixing poorly. We should go back and re-run the imputation with more iterations or possibly adjust our prior to ensure better mixing for this parameter.

# Phylogenetic and Non-Phylogenetic Random Effects

BACE allows users to include both phylogenetic and non-phylogenetic random effects in the imputation models. This is important if multiple replicates of species are included in the dataset (e.g., multiple populations of the same species). In this case, users can specify a non-phylogenetic random effect for species identity in addition to the phylogenetic random effect. This is done by adjusting the `species = FALSE` argument in `bacse_imp`, setting it to TRUE.


```{r}
#| label: non_phylo_random_effects
#| echo: true
#| eval: true
#| warning: false
#| message: false

# Simulate data with multiple replicates per species
set.seed(123)
sim_data2 <- sim_bace(response_type = "poisson",
                   predictor_types = c("gaussian", "binary", "threshold4", "multinomial3"),
                      phylo_signal = c(0.55, 0.75, 0.8, 0.7, 0.7),
                       missingness = c(0.2, 0.3, 0.4, 0.2, 0.5),
                                rr = TRUE,
                           n_cases = 100,
                         n_species = 20,
                           rr_form = list(species = c("x1")))

# Object contains both the simulated data and phylogeny
    data2 <- sim_data2$data
    tree2 <- sim_data2$tree

# View first few rows of the data
    head(data2)         

# We can also make a table of the number of cases per species to confirm that there are multiple replicates per species
    dim(data2)
    length(unique(data2$species))
```                           

We now have a dataset with 100 cases but only 20 species, meaning that there are multiple replicates per species. We can run *BACE* on this dataset while including a non-phylogenetic random effect for species identity as follows:

```{r}
#| label: bace_non_phylo_random_effects
#| echo: true
#| eval: true

bace_impute3 <- bace_imp(fixformula = "y ~ x1 + x2",
                     ran_phylo_form = "~ 1 |species",
                              phylo = tree2,
                               data = data2,
                               runs = 5, nitt = 20000, burnin = 5000, thin = 10, species = TRUE) 


# We can view the final model for y to check that both random effects are included
model_y2 <- bace_impute3$models[["y"]]
summary(model_y2)                                
```

Note that in this case we get a message indicating that both phylogenetic and non-phylogenetic random effects are being included in the models because we probably can decompose the variances. If you try and fit a dataset without multiple replicates per species while setting `species = TRUE` you will get an error because the model cannot be fit.

```{r}
#| label: bace_non_phylo_random_effects_error
#| echo: true
#| eval: true
#| warning: false

bace_impute4 <- bace_imp(fixformula = "y ~ x1 + x2",
                     ran_phylo_form = "~ 1 |species",
                              phylo = tree2,
                               data = data2,
                               runs = 5, nitt = 20000, burnin = 5000, thin = 10, species = TRUE)
```

## Adjusting MCMC Parameters For Convergence

As we can see from the model summary above, some parameters may have low effective sample sizes (ESS) which indicates poor mixing of the MCMC chains. This can be a sign that the imputation is not performing well and that more iterations are needed to achieve convergence. Lets have a look:

```{r}
#| label: check_ess
#| echo: true
#| eval: true

model_x1 <- bace_impute3$models[["x1"]]
summary(model_x1)  

model_x2 <- bace_impute3$models[["x2"]]
summary(model_x2)  
```

As we can see x1 and x2 models have poor mixing and low ESS for some parameters. Obviously, depending on the model complexity and data size etc, some models will need longer runtimes. This is likely because the imputation process has not yet converged. To address this, we can increase the number of iterations (i.e., `nitt`), increase the burn-in period (i.e., `burnin`), and/or adjust the thinning interval (i.e., `thin`) to improve mixing and convergence of the MCMC chains.  

Users can adjust the MCMC parameters (i.e., `nitt`, `thin`, and `burnin`) for each model by providing a list of values for each parameter that corresponds to the order of the formulas provided in the `fixformula` argument. For example, if you have 5 formulas in your `fixformula` list, you can provide a list of 5 values for each MCMC parameter as follows:

```{r}
#| label: mcmc_parameters
#| echo: true
#| eval: true
#| warning: false
#| message: false

# Define MCMC parameters for each model
  nitt_list <- list(60000, 60000, 105000)
  thin_list <- list(10, 10, 10)

# Run BACE with model-specific MCMC parameters
bace_impute5 <- bace_imp(fixformula = "y ~ x1 + x2",
                    ran_phylo_form = "~ 1 |species",
                             phylo = tree2,
                              data = data2,
                              runs = 5, nitt = nitt_list, thin = thin_list, burnin = 5000, species = TRUE)
```

As you can imagine, longer runtimes will mean that `bace_imp` will need to take longer. The diagnostics still suggest possible issues with mixing for some parameters, so we may need to further increase the number of iterations or adjust the priors to improve mixing, however, it's still good to look at the final models to check the model visually.

## Assessing Model Convergence

We need to check whether the numbers of runs we've done has lead to convergence of the imputation process. We can do this by looking at the trace and density plots for the parameters in the models. For example, we can check the model for `y` as follows:


```{r}
#| label: check_convergence
#| echo: true
#| eval: true
#| warning: false
#| message: false

# Assess whether number of runs was enough by looking at the stability of imputed points across runs. Adjust runs if needed
converge <- assess_convergence(bace_impute2, method = "summary")
plot(converge)

# Now that we know that we can run BACE longer

# Fit BACE with a single formula
bace_impute2_2 <- bace_imp(fixformula = "y ~ x1 + x2",
                     ran_phylo_form = "~ 1 |species",
                              phylo = tree,
                               data = data,
                               runs = 15, nitt = 100000, burnin = 10000, thin = 10)  

# Check again for convergence
converge <- assess_convergence(bace_impute2_2, method = "summary")
plot(converge)
                              
```

TO DO: Now that we've tested the convergence function we need to decide how we want to integrate it into the workflow. The slight complicatin is that it takes a bace_imp object as input, so there's a two step process that is needed now rather than working internally. We could have this iterative back and forth and then simply have a final function which picks up from the last run and does 10 more runs and then pools....